// Copyright 2025 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "base/check.h"
#include "base/containers/contains.h"
#include "base/files/file_path.h"
#include "base/logging.h"
#include "base/memory/raw_ptr.h"
#include "base/strings/string_util.h"
#include "base/strings/utf_string_conversions.h"
#include "third_party/protobuf/src/google/protobuf/compiler/code_generator.h"
#include "third_party/protobuf/src/google/protobuf/compiler/cpp/names.h"
#include "third_party/protobuf/src/google/protobuf/compiler/cpp/helpers.h"
#include "third_party/protobuf/src/google/protobuf/compiler/importer.h"
#include "third_party/protobuf/src/google/protobuf/compiler/plugin.h"
#include "third_party/protobuf/src/google/protobuf/descriptor.h"
#include "third_party/protobuf/src/google/protobuf/io/printer.h"

namespace {

using google::protobuf::Descriptor;
using google::protobuf::FieldDescriptor;
using google::protobuf::FileDescriptor;
using google::protobuf::compiler::GeneratorContext;
using google::protobuf::io::Printer;
using google::protobuf::io::ZeroCopyOutputStream;

struct ToValueGeneratorOptions {
  bool generate_stream_operator;
};

class ToValueGenerator : public google::protobuf::compiler::CodeGenerator {
 public:
  ToValueGenerator() = default;
  ~ToValueGenerator() override = default;

  bool Generate(const FileDescriptor* file,
                const std::string& options,  // Options from build system
                GeneratorContext* context,
                std::string* error) const override {
    CHECK(file);

    base::FilePath base_file_path = ToValueFilePath(file->name());
    base::FilePath h_file_path =
        base_file_path.AddExtension(FILE_PATH_LITERAL("to_value.h"));
    base::FilePath cc_file_path =
        base_file_path.AddExtension(FILE_PATH_LITERAL("to_value.cc"));

    const std::unique_ptr<ZeroCopyOutputStream> h_stream(
        context->Open(h_file_path.AsUTF8Unsafe()));
    const std::unique_ptr<ZeroCopyOutputStream> cc_stream(
        context->Open(cc_file_path.AsUTF8Unsafe()));

    Printer h_printer(h_stream.get(), Printer::Options{'$', nullptr});
    Printer cc_printer(cc_stream.get(), Printer::Options{'$', nullptr});

    ToValueGeneratorOptions generator_options;
    generator_options.generate_stream_operator =
        base::Contains(options, "generate_stream_operators");
    std::string include_guard =
        base::ToUpperASCII(h_file_path.AsUTF8Unsafe()) + "_";
    CHECK(base::ReplaceChars(include_guard, ".-/\\", "_", &include_guard));

    std::string kHeader =
        "// Generated by the proto to value plugin.  DO NOT EDIT!\n\n";
    h_printer.Print(kHeader);
    h_printer.Print("#ifndef $g$\n#define $g$\n\n", "g", include_guard);

    if (generator_options.generate_stream_operator) {
      h_printer.Print("#include <iosfwd>\n\n");
    }
    std::vector<std::string> header_include_files = {
        "base/values.h",
        base_file_path.BaseName()
            .AddExtension(FILE_PATH_LITERAL("pb.h"))
            .AsUTF8Unsafe(),
    };
    for (const auto& include : header_include_files) {
      h_printer.Print("#include \"$f$\"\n", "f", include);
    }
    h_printer.Print("\n");

    {
      google::protobuf::compiler::cpp::NamespaceOpener ns(
          google::protobuf::compiler::cpp::Namespace(file), &h_printer);
      for (int i = 0; i < file->message_type_count(); i++) {
        if (!PrintFunctionDeclarations(*file->message_type(i), &h_printer,
                                       error, generator_options)) {
          return false;
        }
      }
    }
    h_printer.Print("\n#endif  // $g$\n", "g", include_guard);

    cc_printer.Print(kHeader);
    cc_printer.Print("\n");
    if (generator_options.generate_stream_operator) {
      cc_printer.Print("#include <ostream>\n\n");
    }
    std::vector<std::string> impl_include_files = {
        "base/base64.h",
        "base/values.h",
        base_file_path.BaseName()
            .AddExtension(FILE_PATH_LITERAL("pb.h"))
            .AsUTF8Unsafe(),
        h_file_path.AsUTF8Unsafe(),
        "components/proto_extras/proto_extras_lib.h",
    };
    for (int i = 0; i < file->dependency_count(); i++) {
      impl_include_files.push_back(
          ToValueFilePath(file->dependency(i)->name())
              .AddExtension(FILE_PATH_LITERAL("to_value.h"))
              .AsUTF8Unsafe());
    }
    for (const auto& include : impl_include_files) {
      cc_printer.Print("#include \"$f$\"\n", "f", include);
    }
    cc_printer.Print("\n");

    {
      google::protobuf::compiler::cpp::NamespaceOpener ns(
          google::protobuf::compiler::cpp::Namespace(file), &cc_printer);
      for (int i = 0; i < file->message_type_count(); i++) {
        if (!PrintFunctionDefinition(*file->message_type(i), &cc_printer, error,
                                     generator_options)) {
          return false;
        }
      }
    }
    return true;
  }

 private:
  base::FilePath ToValueFilePath(std::string_view file_name) const {
#if BUILDFLAG(IS_WIN)
    return base::FilePath(base::ASCIIToWide(file_name)).RemoveExtension();
#else
    return base::FilePath(file_name).RemoveExtension();
#endif
  }

  bool PrintFunctionDeclarations(const Descriptor& message,
                                 Printer* printer,
                                 std::string* error,
                                 const ToValueGeneratorOptions& options) const {
    std::string message_type =
        google::protobuf::compiler::cpp::ClassName(&message);
    printer->Print("base::Value::Dict Serialize(const $m$& message);\n", "m",
                   message_type);
    if (options.generate_stream_operator) {
      printer->Print(
          "std::ostream& operator<<(std::ostream& out, const $m$& message);\n",
          "m", message_type);
    }
    for (int i = 0; i < message.nested_type_count(); i++) {
      if (!PrintFunctionDeclarations(*message.nested_type(i), printer, error,
                                     options)) {
        return false;
      }
    }

    return true;
  }

  bool PrintFunctionDefinition(const Descriptor& message,
                               Printer* printer,
                               std::string* error,
                               const ToValueGeneratorOptions& options) const {
    std::string message_type =
        google::protobuf::compiler::cpp::ClassName(&message);
    printer->Print("base::Value::Dict Serialize(const $m$& message) {\n", "m",
                   message_type);
    printer->Indent();
    printer->Print("base::Value::Dict dict;\n\n");
    for (int j = 0; j < message.field_count(); j++) {
      const FieldDescriptor* field = message.field(j);
      std::string field_name(field->lowercase_name());
      if (field->is_repeated()) {
        printer->Print("if (!message.$f$().empty()) {\n", "f", field_name);
        printer->Indent();
        printer->Print("base::Value::List list;\n");
        printer->Print("for (const auto& value : message.$f$()) {\n", "f",
                       field_name);
        printer->Indent();
        printer->Print("list.Append(");
        PrintFieldToValue(*field, printer);
        printer->Print("(value));\n");
        printer->Outdent();
        printer->Print("}\n");
        printer->Print("dict.Set(\"$f$\", std::move(list));\n", "f",
                       field_name);
        printer->Outdent();
        printer->Print("}\n");
      } else if (field->has_presence()) {
        printer->Print("if (message.has_$f$()) {\n", "f", field_name);
        printer->Indent();
        printer->Print("dict.Set(\"$f$\", ", "f", field_name);
        PrintFieldToValue(*field, printer);
        printer->Print("(message.$f$()));\n", "f", field_name);
        printer->Outdent();
        printer->Print("}\n");
      } else if (field->type() == FieldDescriptor::Type::TYPE_STRING ||
                 field->type() == FieldDescriptor::Type::TYPE_BYTES) {
        printer->Print("if (!message.$f$().empty()) {\n", "f", field_name);
        printer->Indent();
        printer->Print("dict.Set(\"$f$\", ", "f", field_name);
        PrintFieldToValue(*field, printer);
        printer->Print("(message.$f$()));\n", "f", field_name);
        printer->Outdent();
        printer->Print("}\n");
      } else {
        printer->Print("dict.Set(\"$f$\", ", "f", field_name);
        PrintFieldToValue(*field, printer);
        printer->Print("(message.$f$()));\n", "f", field_name);
      }
    }
    printer->Print("if (!message.unknown_fields().empty()) {\n");
    printer->Indent();
    printer->Print(
        "::proto_extras::SerializeUnknownFields(message, dict);\n");
    printer->Outdent();
    printer->Print("}\n");
    printer->Print("return dict;\n");
    printer->Outdent();
    printer->Print("}\n");

    if (options.generate_stream_operator) {
      printer->Print(
          "\nstd::ostream& operator<<(std::ostream& out, const $m$& message) "
          "{\n",
          "m", message_type);
      printer->Indent();
      printer->Print("return out << Serialize(message).DebugString();\n");
      printer->Outdent();
      printer->Print("}\n");
    }

    for (int i = 0; i < message.nested_type_count(); i++) {
      if (!PrintFunctionDefinition(*message.nested_type(i), printer, error,
                                   options)) {
        return false;
      }
    }

    return true;
  }

  void PrintFieldToValue(const FieldDescriptor& field, Printer* printer) const {
    using enum FieldDescriptor::Type;
    switch (field.type()) {
      case TYPE_DOUBLE:
      case TYPE_FLOAT:
        printer->Print("static_cast<double>");
        break;
      case TYPE_INT32:
      case TYPE_INT64:
      case TYPE_UINT64:
      case TYPE_UINT32:
      case TYPE_FIXED64:
      case TYPE_FIXED32:
      case TYPE_SFIXED64:
      case TYPE_SFIXED32:
      case TYPE_SINT64:
      case TYPE_SINT32:
        printer->Print("::proto_extras::ToNumericTypeForValue");
        break;
      case TYPE_BOOL:
        printer->Print("static_cast<bool>");
        break;
      case TYPE_STRING:
        printer->Print("static_cast<std::string>");
        break;
      case TYPE_BYTES:
        printer->Print("base::Base64Encode");
        break;
      case TYPE_ENUM:
        printer->Print("$t$_Name", "t",
                       google::protobuf::compiler::cpp::QualifiedClassName(
                           field.enum_type()));
        break;
      case TYPE_MESSAGE:
      case TYPE_GROUP:
        printer->Print("$p$::Serialize", "p",
                       google::protobuf::compiler::cpp::Namespace(field.message_type()));
        break;
    }
  }
};

}  // namespace

int main(int argc, char** argv) {
  ToValueGenerator generator;
  return google::protobuf::compiler::PluginMain(argc, argv, &generator);
}
